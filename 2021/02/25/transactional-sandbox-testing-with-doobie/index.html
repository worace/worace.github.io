<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="last-modified" content="2022-02-23T18:55:36-08:00" />

  <title>
    
      Transactional Sandbox Testing with Doobie
    
  </title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@300;400&family=Lora:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet"> 

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/TroutIcon48x48.png">
  <link rel="alternate" type="application/atom+xml" title="Horace Williams" href="/atom.xml">

  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117025935-1"></script>
  <script>
   window.dataLayer = window.dataLayer || [];
   function gtag(){dataLayer.push(arguments);}
   gtag('js', new Date());

   gtag('config', 'UA-117025935-1');
  </script>
  
</head>


  <body>

    <div class="container content">
      
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">Horace Williams</a>
        </h3>
        <ul class="nav-links">
          <li><a href="/about">about</a></li>
          <li><a target="_blank" class="nav-twitter" href="https://twitter.com/worace"><svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><path d="M 32 6 C 26.568583 6 22.160643 10.388731 22.042969 15.792969 C 17.240727 15.216998 14.113589 13.421507 12.195312 11.652344 C 10.067982 9.6903754 9.3945312 7.9472656 9.3945312 7.9472656 A 1.50015 1.50015 0 0 0 6.8007812 7.5996094 C 6.8007812 7.5996094 5 10 5 13.5 C 5 15.500985 5.6317952 16.981554 6.3847656 18.236328 C 6.3570276 18.223338 6.1699219 18.158203 6.1699219 18.158203 A 1.50015 1.50015 0 0 0 4.0058594 19.636719 C 4.0058594 19.636719 4.5832039 23.856843 8.5507812 26.941406 L 8.1367188 27.044922 A 1.50015 1.50015 0 0 0 7.1972656 29.244141 C 7.1972656 29.244141 7.8700527 30.382221 9.2792969 31.580078 C 10.11485 32.290298 11.34227 33.023169 12.789062 33.701172 C 11.012271 34.35044 8.362818 35 4.5 35 A 1.50015 1.50015 0 0 0 3.3710938 37.488281 C 3.3710938 37.488281 4.5173251 38.751002 6.7832031 39.849609 C 9.0490812 40.948217 12.539474 42 17.5 42 C 26.219697 42 32.484656 37.817151 36.394531 32.515625 C 40.304407 27.214099 42 20.861111 42 16 C 42 15.691547 41.980739 15.387437 41.953125 15.085938 C 44.064371 13.051602 44.856626 11.522235 44.894531 11.447266 C 45.084531 11.066266 45.01375 10.608688 44.71875 10.304688 C 44.42475 9.9996875 43.969031 9.9137969 43.582031 10.091797 L 43.419922 10.166016 C 43.280922 10.230016 43.141953 10.294422 43.001953 10.357422 C 43.408953 9.7084219 43.730125 9.014875 43.953125 8.296875 C 44.077125 7.900875 43.943234 7.4669375 43.615234 7.2109375 C 43.287234 6.9549375 42.835469 6.9275312 42.480469 7.1445312 C 41.258221 7.8873594 40.086652 8.40739 38.867188 8.7558594 C 37.072578 7.0534724 34.656873 6 32 6 z M 32 9 C 35.883178 9 39 12.116822 39 16 C 39 20.138889 37.445593 26.035901 33.980469 30.734375 C 30.515344 35.432849 25.280303 39 17.5 39 C 13.7348 39 11.230189 38.318942 9.3535156 37.582031 C 11.319341 37.276755 13.011947 36.869367 14.228516 36.398438 C 16.338182 35.581792 17.476563 34.638672 17.476562 34.638672 A 1.50015 1.50015 0 0 0 16.863281 32.044922 C 14.140556 31.364241 12.394328 30.263307 11.298828 29.345703 L 12.863281 28.955078 A 1.50015 1.50015 0 0 0 13.039062 26.099609 C 9.7939415 24.851486 8.4312292 23.086373 7.734375 21.607422 C 8.5823538 21.782967 9.3718961 22 10.5 22 A 1.50015 1.50015 0 0 0 11.169922 19.158203 C 11.169922 19.158203 8 17.7 8 13.5 C 8 12.745947 8.2088435 12.268355 8.3613281 11.697266 C 8.884507 12.400354 9.3156815 13.07859 10.160156 13.857422 C 12.734824 16.231954 16.990366 18.653154 23.419922 18.998047 A 1.50015 1.50015 0 0 0 25 17.5 L 25 16 C 25 12.116822 28.116822 9 32 9 z"/></svg>
</a></li>
        </ul>
      </header>
      

      <main>
        <article class="post">
  <h1 class="post-title">Transactional Sandbox Testing with Doobie</h1>
  <h2 class="post-subtitle"><em></em></h2>
  <time datetime="2021-02-25T00:00:00-08:00" class="post-date">25 Feb 2021</time>
  <p>Lately I’ve been working a lot with Rob Norris’ excellent <a href="https://github.com/tpolecat/doobie">doobie</a> library for managing database queries in Scala. Here are a few notes on how I set up my test suite to cleanup state for tests that used the DB via doobie.</p>

<h2 id="context">Context</h2>

<p>This is one approach to isolating database-dependent tests so state from one test doesn’t bleed into the next. The idea is to wrap each test (and all of its database interactions) in a single top-level transaction which never commits. Then in your test teardown, you simply rollback the transaction which reverts the DB to its pristine state. This is the default testing setup in many full-stack web frameworks like Rails or <a href="https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.Sandbox.html">Phoenix</a>, and while it can have some drawbacks in certain scenarios it’s overall a great experience.</p>

<p>One benefit in particular is this allows your database-dependent tests in parallel, without having to manage a bunch of separate ad-hoc test DB instances (you just use a single shared, persistent test instance, which never actually gets any data written to it).</p>

<h2 id="transaction-based-tests-with-doobie">Transaction-based Tests with Doobie</h2>

<p>Doobie does provide an API (<a href="https://javadoc.io/doc/org.tpolecat/doobie-core_2.12/latest/doobie/util/transactor$$Transactor$.html">Transactor.after.set</a>) for disabling the default “commit after transact” behavior temporarily. However I found this to be a little finicky, especially if I had tests that involved multiple <code class="language-plaintext highlighter-rouge">ConnectionIO</code>s which might get committed separately. There’s <a href="https://github.com/tpolecat/doobie/issues/535#issuecomment-311202214">a bit of discussion in this issue</a>, but in my case I wanted to be able to run a “full slice” of my application, which might involve many different <code class="language-plaintext highlighter-rouge">ConnectionIO</code>s as well as some invocations of my application-level effect, which in this case is <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>.</p>

<p>So I wired up a base <code class="language-plaintext highlighter-rouge">SandboxTest</code> which provides this functionality by manipulating a setting on a JDBC connection before passing it off to doobie. Note that I’m also using <a href="https://github.com/typelevel/munit-cats-effect">munit-cats-effect</a> here which allows tests to return <code class="language-plaintext highlighter-rouge">IO[Assertion]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Base test for providing non-commiting Transactor[IO] as an munit Fixture</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">SandboxTest</span> <span class="k">extends</span> <span class="nv">munit</span><span class="o">.</span><span class="py">CatsEffectSuite</span> <span class="o">{</span>
  <span class="c1">// set up a connection pool to your test DB like normal</span>
  <span class="k">def</span> <span class="nf">startPool</span><span class="k">:</span> <span class="kt">HikariDataSource</span> <span class="o">=</span> <span class="o">???</span>
  <span class="c1">// munit Suite-level fixtures for holding the connection pool</span>
  <span class="c1">// this happens once for each test class</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">pool</span><span class="k">:</span> <span class="kt">HikariDataSource</span> <span class="o">=</span> <span class="kc">null</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">beforeAll</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="n">pool</span> <span class="k">=</span> <span class="n">startPool</span> <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">afterAll</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nv">pool</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>

  <span class="c1">// Context to provide into the individual tests as a scenario</span>
  <span class="c1">// This can be expanded to include an instance of your application,</span>
  <span class="c1">// some custom fixture instances, or whatever else you need to support your test examples</span>
  <span class="c1">// Note the connection itself must be passed through so it's available in teardown</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Context</span><span class="o">(</span><span class="n">conn</span><span class="k">:</span> <span class="kt">Connection</span><span class="o">,</span> <span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span>
  <span class="k">val</span> <span class="nv">fixture</span> <span class="k">=</span> <span class="nc">FunFixture</span><span class="o">[</span><span class="kt">Context</span><span class="o">](</span>
    <span class="n">setup</span> <span class="k">=</span> <span class="o">{</span> <span class="n">test</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="nv">conn</span> <span class="k">=</span> <span class="nv">pool</span><span class="o">.</span><span class="py">getConnection</span><span class="o">()</span>
      <span class="c1">// Prevent the connection from committing early on your behalf</span>
      <span class="nv">conn</span><span class="o">.</span><span class="py">setAutoCommit</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="c1">// Make a transactor wrapping this single connection instance, rather than the whole pool</span>
      <span class="k">val</span> <span class="nv">xa</span> <span class="k">=</span> <span class="nv">Transactor</span><span class="o">.</span><span class="py">fromConnection</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span>
        <span class="n">conn</span><span class="o">,</span>
        <span class="nv">Blocker</span><span class="o">.</span><span class="py">liftExecutionContext</span><span class="o">(</span><span class="nv">doobie</span><span class="o">.</span><span class="py">util</span><span class="o">.</span><span class="py">ExecutionContexts</span><span class="o">.</span><span class="py">synchronous</span><span class="o">)</span>
      <span class="o">)</span>
      <span class="k">val</span> <span class="nv">rollbackXa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Transactor</span><span class="o">.</span><span class="py">strategy</span><span class="o">.</span><span class="py">set</span><span class="o">(</span>
        <span class="n">xa</span><span class="o">,</span>
        <span class="c1">// Disable Doobie's default commit behavior</span>
        <span class="nv">Strategy</span><span class="o">.</span><span class="py">default</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">after</span> <span class="k">=</span> <span class="nc">DoNothing</span><span class="o">,</span> <span class="n">oops</span> <span class="k">=</span> <span class="nc">DoNothing</span><span class="o">,</span> <span class="n">always</span> <span class="k">=</span> <span class="nc">DoNothing</span><span class="o">)</span>
      <span class="o">)</span>
      <span class="nc">Context</span><span class="o">(</span><span class="n">conn</span><span class="o">,</span> <span class="n">rollbackXa</span><span class="o">)</span>
    <span class="o">},</span>
    <span class="n">teardown</span> <span class="k">=</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
      <span class="c1">// After the test, rollback and close the connection</span>
      <span class="c1">// This cleans up any changes you made to the DB during your test</span>
      <span class="nv">ctx</span><span class="o">.</span><span class="py">conn</span><span class="o">.</span><span class="py">rollback</span>
      <span class="nf">if</span> <span class="o">(!</span><span class="nv">ctx</span><span class="o">.</span><span class="py">conn</span><span class="o">.</span><span class="py">isClosed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nv">ctx</span><span class="o">.</span><span class="py">conn</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now each test class that uses this base can use its fixture to get a wrapped doobie transactor:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TransactionalExampleTest</span> <span class="k">extends</span> <span class="nc">SandboxTest</span> <span class="o">{</span>
  <span class="nv">fixture</span><span class="o">.</span><span class="py">test</span><span class="o">(</span><span class="s">"transactional test"</span><span class="o">)</span> <span class="o">{</span> <span class="n">ctx</span><span class="k">:</span> <span class="kt">Context</span> <span class="o">=&gt;</span>
    <span class="k">val</span> <span class="nv">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="c1">// these queries will actually run against your database and yield real results</span>
      <span class="c1">// but any changes they make will be cleaned up at the end of the test</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">sql</span><span class="s">"insert into foods (name) values ('pizza')"</span><span class="o">.</span><span class="py">update</span><span class="o">.</span><span class="py">run</span><span class="o">.</span><span class="py">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>
      <span class="n">names</span> <span class="k">&lt;-</span> <span class="n">sql</span><span class="s">"select name from foods"</span><span class="o">.</span><span class="py">query</span><span class="o">[</span><span class="kt">String</span><span class="o">].</span><span class="py">to</span><span class="o">[</span><span class="kt">Vector</span><span class="o">].</span><span class="py">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
      <span class="nf">assertEquals</span><span class="o">(</span><span class="n">names</span><span class="o">,</span> <span class="nc">Vector</span><span class="o">(</span><span class="s">"pizza"</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For brevity I’ve omitted the imports from these snippets but you can see the fully worked example in this <a href="https://github.com/worace/doobie-transactional-tests">github repo</a>.</p>

<h2 id="other-approaches">Other Approaches</h2>

<h3 id="explicit-truncation">Explicit Truncation</h3>

<p>You can of course handle the db state problem manually, by explicitly re-setting the state of your db between each example. This could be done either by truncating all of your tables 1 by 1, or dropping the whole schema and re-migrating it.</p>

<p>This isn’t the worst, but dropping and re-creating schemas can be slow, and truncating often requires you to keep your test truncation code up to date as you evolve your schema. And perhaps the biggest issue is this strategy limits your ability to run db-reliant tests in parallel, since they aren’t isolated from one another in a transaction.</p>

<h3 id="temp-or-in-memory-db-eg-h2-or-sqlite">Temp or In-Memory DB (e.g. H2 or SQLite)</h3>

<p>You can also use a temporary (often in-memory) DB for your tests. SQLite and the pure-Java H2 database are popular choices for this, as they can be run locally as libraries (don’t have to shell out to manage them) and have an in-memory mode that discards data at the end of your test runs.</p>

<p>These DBs are fast and cheap to create, so you can afford to spin up an entirely new DB for every single test run, which gives great isolation between tests while still keeping things pretty fast.</p>

<p>However unless you’re actually running SQLite or H2 in production, you’ll be using a different DB between your test and prod environments. Which at best is kind of sketchy, because you’ll likely paper over problems that won’t reveal themselves until you deploy to prod.</p>

<p>But more likely it’s just not viable, because you’re probably leveraging DB-specific features (PostGIS, anyone?) which won’t exist in something like H2 or SQLite.</p>

<p>Several years ago there seemed to be a trend toward treating SQL DBs as interchangeable boxes that your ORM’s SQL interface (AcitveRecord, Hibernate, etc) would paper over as needed.</p>

<p>But nowadays we’re more happy to rely on our DBs as processing tools and not just generic relational stores. Which is great IMO – Postgres in particular is super powerful and we should leverage it – but it means you probably don’t want to try to use something different for testing.</p>

<h3 id="testcontainers">TestContainers</h3>

<p>Another approach that has been gaining a lot of popularity is using Docker containers to run dedicated test db instances. This lets you get a real Postgres or MySQL instance that can still be easily thrown away so you don’t deal with tainted state between tests.</p>

<p>And in recent years the <a href="https://www.testcontainers.org/">TestContainers</a> project has made this strategy much easier by providing high quality library bindings for programmatically manipulating containers, so you can integrate the container lifecycle with your test framework without relying external tools like docker-compose.</p>

<p>There’s also a great library for integrating it with popular Scala test frameworks like Scalatest and Munit: <a href="https://github.com/testcontainers/testcontainers-scala">testcontainers-scala</a>.</p>

<p>Here’s an example of what it looks like in munit:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.dimafeng.testcontainers.PostgreSQLContainer</span>
<span class="k">import</span> <span class="nn">com.dimafeng.testcontainers.munit.TestContainerForEach</span>

<span class="k">class</span> <span class="nc">TestContainersExampleTest</span> <span class="k">extends</span> <span class="nv">munit</span><span class="o">.</span><span class="py">FunSuite</span> <span class="k">with</span> <span class="nc">TestContainerForEach</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">containerDef</span> <span class="k">=</span> <span class="nv">PostgreSQLContainer</span><span class="o">.</span><span class="py">Def</span><span class="o">()</span>

  <span class="nf">test</span><span class="o">(</span><span class="s">"test postgres with testcontainer"</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">withContainers</span> <span class="o">{</span> <span class="n">postgresContainer</span> <span class="k">=&gt;</span>
      <span class="o">???</span> <span class="c1">// Do stuff with postgres</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So overall this is pretty nice, and it can be configured in a lot of different ways. You can achieve various configurations like 1 container per test, 1 per suite, a mix of multiple containers at once, etc.</p>

<p>However the biggest downside IMHO is that it can be pretty slow. Especially if you want to rely on containers for providing state isolation, you’ll need a fresh one for each test, which can take sevral seconds. You also have to apply schema migrations to those fresh containers to get them ready to use.</p>

<p>Here’s a gif showing a comparison from the example repo linked above:</p>

<p><img src="/public/images/transactional_vs_testcontainers.gif" alt="TestContainers vs. Transactional Tests" /></p>

<p>The DB interactions in these tests are admittedly pretty simplistic, but as you can see that’s running 100 transaction/rollback tests (which actually insert and read data) before the first test container can even get booted.</p>

<p>I think a lot of people that use this approach rely on it for a relatively small number of integration tests where you’re extensively exercising the system in a few complex scenarios. Then they rely on a mix of IO-less unit tests and/or mocking to test the rest of the system without the DB at all. So if that fits the profile of your application, it’s probably a good way to go.</p>

<p>Unfortunately in many of the applications I work on, the RDBMS is a significant part of the application logic, so most of the things that would be meaningful for me to test need to rely on it. So in these cases its more beneficial to me to have fast transactional tests than more isolated container-based tests. But as always YMMV.</p>

<p>And of course there are some cases where the transaction/rollback approach doesn’t work well:</p>

<ul>
  <li>Your application actually needs to do tricky stuff of its own with transaction boundaries, so having them managed by the test suite is problematic</li>
  <li>You need an external process to see the results of your db operations, in which case transaction isolation won’t work. This is common when running something like a browser-driven acceptance test, where an external process like selenium needs to connect to a live instance of your app and drive it.</li>
</ul>

<p>So in these cases its great to have the TestContainers approach to fall back on.</p>

</article>

      </main>

    </div>

  </body>
</html>
