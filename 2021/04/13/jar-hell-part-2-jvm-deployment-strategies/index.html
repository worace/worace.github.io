<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="last-modified" content="2022-02-23T18:47:26-08:00" />

  <title>
    
      Welcome to JAR Hell, Part 2 (Application Deployment Strategies)
    
  </title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@300;400&family=Lora:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet"> 

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/TroutIcon48x48.png">
  <link rel="alternate" type="application/atom+xml" title="Horace Williams" href="/atom.xml">

  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117025935-1"></script>
  <script>
   window.dataLayer = window.dataLayer || [];
   function gtag(){dataLayer.push(arguments);}
   gtag('js', new Date());

   gtag('config', 'UA-117025935-1');
  </script>
  
</head>


  <body>

    <div class="container content">
      
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">Horace Williams</a>
        </h3>
        <ul class="nav-links">
          <li><a href="/about">about</a></li>
          <li><a target="_blank" class="nav-twitter" href="https://twitter.com/worace"><svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><path d="M 32 6 C 26.568583 6 22.160643 10.388731 22.042969 15.792969 C 17.240727 15.216998 14.113589 13.421507 12.195312 11.652344 C 10.067982 9.6903754 9.3945312 7.9472656 9.3945312 7.9472656 A 1.50015 1.50015 0 0 0 6.8007812 7.5996094 C 6.8007812 7.5996094 5 10 5 13.5 C 5 15.500985 5.6317952 16.981554 6.3847656 18.236328 C 6.3570276 18.223338 6.1699219 18.158203 6.1699219 18.158203 A 1.50015 1.50015 0 0 0 4.0058594 19.636719 C 4.0058594 19.636719 4.5832039 23.856843 8.5507812 26.941406 L 8.1367188 27.044922 A 1.50015 1.50015 0 0 0 7.1972656 29.244141 C 7.1972656 29.244141 7.8700527 30.382221 9.2792969 31.580078 C 10.11485 32.290298 11.34227 33.023169 12.789062 33.701172 C 11.012271 34.35044 8.362818 35 4.5 35 A 1.50015 1.50015 0 0 0 3.3710938 37.488281 C 3.3710938 37.488281 4.5173251 38.751002 6.7832031 39.849609 C 9.0490812 40.948217 12.539474 42 17.5 42 C 26.219697 42 32.484656 37.817151 36.394531 32.515625 C 40.304407 27.214099 42 20.861111 42 16 C 42 15.691547 41.980739 15.387437 41.953125 15.085938 C 44.064371 13.051602 44.856626 11.522235 44.894531 11.447266 C 45.084531 11.066266 45.01375 10.608688 44.71875 10.304688 C 44.42475 9.9996875 43.969031 9.9137969 43.582031 10.091797 L 43.419922 10.166016 C 43.280922 10.230016 43.141953 10.294422 43.001953 10.357422 C 43.408953 9.7084219 43.730125 9.014875 43.953125 8.296875 C 44.077125 7.900875 43.943234 7.4669375 43.615234 7.2109375 C 43.287234 6.9549375 42.835469 6.9275312 42.480469 7.1445312 C 41.258221 7.8873594 40.086652 8.40739 38.867188 8.7558594 C 37.072578 7.0534724 34.656873 6 32 6 z M 32 9 C 35.883178 9 39 12.116822 39 16 C 39 20.138889 37.445593 26.035901 33.980469 30.734375 C 30.515344 35.432849 25.280303 39 17.5 39 C 13.7348 39 11.230189 38.318942 9.3535156 37.582031 C 11.319341 37.276755 13.011947 36.869367 14.228516 36.398438 C 16.338182 35.581792 17.476563 34.638672 17.476562 34.638672 A 1.50015 1.50015 0 0 0 16.863281 32.044922 C 14.140556 31.364241 12.394328 30.263307 11.298828 29.345703 L 12.863281 28.955078 A 1.50015 1.50015 0 0 0 13.039062 26.099609 C 9.7939415 24.851486 8.4312292 23.086373 7.734375 21.607422 C 8.5823538 21.782967 9.3718961 22 10.5 22 A 1.50015 1.50015 0 0 0 11.169922 19.158203 C 11.169922 19.158203 8 17.7 8 13.5 C 8 12.745947 8.2088435 12.268355 8.3613281 11.697266 C 8.884507 12.400354 9.3156815 13.07859 10.160156 13.857422 C 12.734824 16.231954 16.990366 18.653154 23.419922 18.998047 A 1.50015 1.50015 0 0 0 25 17.5 L 25 16 C 25 12.116822 28.116822 9 32 9 z"/></svg>
</a></li>
        </ul>
      </header>
      

      <main>
        <article class="post">
  <h1 class="post-title">Welcome to JAR Hell</h1>
  <h2 class="post-subtitle"><em>Part 2: Application Deployment Strategies</em></h2>
  <time datetime="2021-04-13T09:40:00-07:00" class="post-date">13 Apr 2021</time>
  <p>In <a href="/2021/04/04/jar-hell-part-1-compilation-classpath-libraries/">Part 1</a>, we looked at the basic model for loading and executing code on the JVM.</p>

<p>We saw how Classes (usually represented by <code class="language-plaintext highlighter-rouge">.class</code> files) provide the basic unit for JVM code, and how the Classpath makes classes (usually organized into JARs) available to the JVM at compile- and runtime. And we saw how tools like Maven help us use external libraries by fetching them from package repositories and incorporating them into the local Classpath.</p>

<p>But what about production deployments?</p>

<p>The Classpath still exists regardless of whether we’re running code on our Macbook or on a server in AWS, but for production, we’d prefer to run <em>without</em> a build tool, and ideally without any system dependencies beyond a Java Runtime Environment.</p>

<p>In this post, we’ll look at several ways to accomplish this.</p>

<h3 id="preface-applications-vs-libraries">Preface: Applications vs. Libraries</h3>

<p>Software projects can be coarsely divided into 2 groups: Libraries and Applications. Libraries are consumed by other code, while Applications are meant to run on their own. On the JVM, both types of software can be packaged as JARs, but there are some common conventions around how each gets handled.</p>

<p>In general, library JARs only contain a “shallow” bundle of compiled <code class="language-plaintext highlighter-rouge">.class</code> files, meaning they include <em>their own</em> direct code but not that of their dependencies. This is sometimes also called a “skinny” JAR.</p>

<p>You might ask how this is useful, since if we depend on library A, and A depends on B, we obviously can’t run our application without also having B. But the answer is that the developers of A expect you to retrieve B on your own after consulting A’s dependency manifest (i.e. its Maven POM). When dealing with <em>libraries</em> we prefer smaller, granular packages that can be managed programmatically by a build tool. This gives downstream users more flexibility to cache packages, handle dependency conflicts, etc.</p>

<p><em>Applications</em>, by contrast, are not intended for distribution to other developers or consumption by other code. Rather, they’re meant to run as standalone artifacts (e.g. they probably include a <code class="language-plaintext highlighter-rouge">main</code> method).</p>

<p>Applications require a deployment strategy which, one way or another, gets the application’s own code, along with a fully resolved Classpath containing any necessary libraries, into the target runtime environment. This type of deployment – running compiled applications along with their dependencies – is what we’re focused on in this article.</p>

<h2 id="deployment-for-the-jvm">Deployment for the JVM</h2>

<p>Luckily, the JVM makes the actual “run the code” portion fairly easy – as long as you don’t get too crazy with native dependencies (e.g <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a>), or shelling out to system commands, you should be able to run your app on any server with the proper <a href="https://www.oracle.com/java/technologies/javase-jre8-downloads.html">JRE</a> version.</p>

<p>But you <em>do</em> have to worry about getting all of the compiled code into the right place. There are a lot of ways to do this, so we’ll look at several options:</p>

<ul>
  <li>Push JARs to a server and run</li>
  <li>Uberjars</li>
  <li>WAR files / J2EE</li>
  <li>Docker Images</li>
  <li>GraalVM Native Images</li>
</ul>

<h3 id="push-and-script">Push and Script</h3>

<p>For starters we can always just do a straightforward upload of the library JARs our build tool resolves for our Classpath, along with the one it has create for our own code.</p>

<p>For example if we’re using Maven, we’ll end up with a classpath / run command (locally) that looks something like <code class="language-plaintext highlighter-rouge">java -cp ./target/my-app.jar:~/.m2/repository/foo.jar:~/.m2/repository/bar.jar com.mycorp.MyMainClass</code>. So to run in prod, we have to push those same 3 JARs into our target environment, and run a <code class="language-plaintext highlighter-rouge">java</code> command with them in the same Classpath arrangement.</p>

<p>There are a lot of ways to achieve this, so I tend to think of it as a rough pattern more than a specific implementation.</p>

<p>Sbt’s <a href="https://github.com/sbt/sbt-native-packager">native-packager plugin</a> is a great example of a tool that does this really well. It can package all of your JARs into a Zip archive or tarball, along with a handy run script (you can see the <a href="https://github.com/sbt/sbt-native-packager/blob/master/src/main/resources/com/typesafe/sbt/packager/archetypes/scripts/bash-template">template</a> for these) that will kick everything off. There are likely similar plugins for Maven or Gradle.</p>

<h3 id="uberfatassembly-jars">Uber/Fat/Assembly JARs</h3>

<p>As mentioned in the Libraries vs. Applications section, we’ve so far been dealing with “skinny” jars containing 1 project’s compiled code.</p>

<p>In order to make a larger application work, we have to put a bunch of them side by side on the Classpath. This works fine, but can get annoying because you end up with dozens or even hundreds of JARs to cart around. What if you could just get it all onto <em>one</em> JAR?</p>

<p>It turns out JARs <em>can</em> be used (abused?) in this way, by creating what’s called an “Uber” JAR (AKA “Assembly” or “Fat” JAR). An uberjar flattens out the compiled code from your project’s JAR, <em>plus the compiled code from all the JARs on its classpath</em> into a single output JAR. It’s basically a whole bunch of JARs squished into one.</p>

<p>The benefit of this is that the final product no longer has any dependencies. Its whole Classpath is just the one resulting JAR, and your whole deployment model can consist of uploading the uberjar to production and invoking <code class="language-plaintext highlighter-rouge">java -jar my-application.jar</code>. It’s sort of the JAR equivalent of building a single executable binary out of a language like Go or Rust.</p>

<p>The simplicity of the single-file deployment strategy has made uberjars popular in recent years. They’re especially common in the Hadoop/Spark ecosystem, but get used a lot for web services or other server applications as well.</p>

<p>Most build tools can either build uberjars out of the box or provide a plugin for doing it: <a href="https://maven.apache.org/plugins/maven-shade-plugin/">Maven Shade Plugin</a>, <a href="https://github.com/sbt/sbt-assembly">sbt-assembly</a>, <a href="https://github.com/technomancy/leiningen/blob/master/doc/TUTORIAL.md#uberjar">Leiningen (built in)</a>. Consult the README for whichever of these you’re using for more details.</p>

<h4 id="other-uberjar-topics">Other Uberjar Topics</h4>

<p>While the uberjar process is not conceptually so complex (unzip + rezip), in practice there are some subtleties and advanced features that can make things quite complicated, especially for larger projects. Here are a few uberjar advanced topics you may run into.</p>

<h5 id="resource-deduplication">Resource Deduplication</h5>

<p>In addition to the usual <code class="language-plaintext highlighter-rouge">.class</code> files, JARs can also contain other non-code files called “resources”. These could be configuration files, static assets, etc., and can be accessed programmatically via Java <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html">APIs</a>.</p>

<p>The catch is that resource files in a JAR have to be unique (by path), so when you squash all your deps into a single uberjar, you’ll likely run into conflicts that have to be resolved. Different tools have different ways of configuring this, but it’s common to specify a “Merge Strategy” for handling these conflicts. For example here’s <a href="https://github.com/sbt/sbt-assembly#merge-strategy">sbt-assembly’s docs on the subject</a>.</p>

<p>Depending on your application and what libraries you’re using, Resource Deduplication can either be a minor annoyance or a huge headache. For example a lot of JARs include metadata files like <code class="language-plaintext highlighter-rouge">META-INF/manifest.mf</code> that can be discarded – no big deal. But you can also find collisions between important configuration files which lead to creative workarounds like concatenating and hoping the combined file will satisfy both of the libraries that provided it.</p>

<p><strong>Edit:</strong> This article has prompted some interesting discussion around the Pros and Cons of the mult-JAR vs Uberjar strategies with regard to resource collisions. <a href="https://github.com/worace/multi-jar-vs-uberjar-resources">Here is an example Github Repo</a> demonstrating some of these issues. TL;DR multi-JAR Classpaths are still prone to resource collisions, they just will often happen silently with a “first one wins” strategy. So building an Uberjar <em>can</em> be a benefit in these cases because most build tools will warn you about these conflicts force you to resolve them at build time.</p>

<h5 id="shading">Shading</h5>

<p>Shading is a technique for dealing with certain kinds of dependency conflicts by relocating code from one version of a package into a different namespace, thus allowing it to coexist with another version of itself.</p>

<p>Shading comes up a lot in the context of Uberjars, because large Uberjars tend to produce the conditions where shading is necessary. But shading can be applied just as well to library JARs, and some library publishers consider it good etiquette to shade copies of commonly used libraries they depend on (Guava, anyone?) as a means of saving downstream users from potential dependency conflicts. But the rules and conventions around all this are fuzzy, so what you encounter in the wild may vary.</p>

<p>One point however is worth emphasizing: <strong>If you’re going to bundle Classes you don’t own into a JAR you’re publishing, you should shade them</strong>. Ideally you really wouldn’t do this at all, but sometimes people get into a bind and have to bundle a transitive dependency for whatever reason. Shading in these cases can save your consumers from unresolvable dependency conflicts.</p>

<p>Shading is a complex topic in its own right so we’ll cover it more in Part 3, which focuses on dependency conflicts and classpath pathologies. In the meantime here are some good resources:</p>

<ul>
  <li><a href="https://medium.com/@akhaku/java-class-shadowing-and-shading-9439b0eacb13">Java Class Shadowing and Shading</a></li>
  <li><a href="https://softwareengineering.stackexchange.com/questions/297276/what-is-a-shaded-java-dependency">Stack Exchange: What is a “shaded” Java dependency?</a></li>
</ul>

<h3 id="war-files-and-j2ee">WAR Files and J2EE</h3>

<p><a href="https://docs.oracle.com/cd/E19199-01/816-6774-10/a_war.html">WAR Files</a> are a special JAR variant used for deploying certain types of Java web applications in the J2EE ecosystem. J2EE is a whole can of worms that I honestly don’t know much about, nor am I very interested in learning. But it does come up a lot so it’s worth touching on here.</p>

<p>In short, these applications are designed to deploy not to generic VMs (like a bare Ubuntu EC2 instance with <code class="language-plaintext highlighter-rouge">java</code> installed) but rather into specialized Java-based <a href="https://en.wikipedia.org/wiki/List_of_application_servers#Java">Application Servers</a>, like <a href="http://tomcat.apache.org/">Apache Tomcat</a>. Your company would run one or more of these Tomcat instances, which get treated as shared infrastructure, and individual applications get pacakged into WARs and deployed into a pre-existing App Server, probably along with a bunch of other application WAR files.</p>

<p>The Application Server manages your app’s lifecycle, along with providing some shared system services, and because of these interactions extra care must be taken to ensure the 2 components cooperate well, which is what the WAR spec provides.</p>

<p><a href="https://javapipe.com/blog/tomcat-application-server/">This article</a> gives a good overview of this whole system. <a href="https://octopus.com/blog/application-server-vs-uberjar">Here’s another good one</a> about WARs specifically.</p>

<p>Despite my skepticism and poorly masked disdain for all this, it is kind of amusing to read about. If you squint right, running WARs via Tomcat isn’t so different from running “pods” of “containers” on abstracted machines via kubernetes, just with a lot more enterprise-y pocket protector vibes.</p>

<p>And the decline of one is certainly related to the rise of the other – while there are plenty of J2EE deployments running out there, much of the industry has moved away from this model. These days people care more about cloud portability and deployment standardization (e.g. running with Docker or deploying via the <a href="https://12factor.net/">12 Factor Model</a>). This makes highly customized, language-specific infrastructure less appealing than a giant uberjar you can run with a single <code class="language-plaintext highlighter-rouge">java -jar</code> command.</p>

<h3 id="docker-and-container-images">Docker and Container Images</h3>

<p>Ironically one of Java’s initial selling points – simplicity of deployment – has been somewhat diminished by the proliferation of Docker. Now that everyone’s prod environments are “BYO Container” anyway, the benefit of just putting the JRE on all your servers doesn’t matter as much.</p>

<p>Nevertheless, the JVM runs just fine in Docker, and in many cases, you can grab an appropriate base image (like <a href="https://hub.docker.com/_/openjdk">OpenJDK</a>), stuff your JARs into it, and go.</p>

<p>However it’s worth emphasizing: using Docker doesn’t change the fundamental JVM equation of Java Runtime + Classpath full of JARs = Application. The only difference is now the base image provides the JRE, and you’ll be loading your Classpath JARs into a container image rather than onto a bare server or VM.</p>

<p>So usually you’ll be putting into your Docker image some variation of one of the previous models:</p>

<ul>
  <li>Put your compiled code and all your dependencies into a docker image and include an entrypoint command that invokes them with the proper settings and Classpath. Basically the “Push &amp; Script” strategy but in Docker. (sbt’s <a href="https://www.scala-sbt.org/sbt-native-packager/formats/docker.html">native-packager</a> plugin does this)</li>
  <li>Build an uberjar and put it in a JDK docker image. Your Dockerfile <code class="language-plaintext highlighter-rouge">CMD</code> setting will be something like <code class="language-plaintext highlighter-rouge">java -jar /path/to/that.jar</code></li>
  <li>Use a dedicated Java-to-Container build plugin like <a href="https://github.com/GoogleContainerTools/jib">Google’s Jib</a>.</li>
</ul>

<h4 id="jib-java-specific-container-image-builds">Jib: Java-specific Container Image Builds</h4>

<p><a href="https://github.com/GoogleContainerTools/jib">Jib</a> is a new-ish project providing a pure-Java build tool for the <a href="https://github.com/opencontainers/image-spec">OCI Image Spec</a>. This is interesting for a few reasons.</p>

<p>First, because it’s implemented in Java, Jib integrates into existing JVM build tools. Normally, running <code class="language-plaintext highlighter-rouge">docker build</code> requires an RPC connection to a Docker daemon process on your machine. You need to have Docker installed, and the build process has to copy things back and forth between the daemon and the docker client. Jib allows you to sidestep all this and keep things entirely within your Maven or Gradle build.</p>

<p>Second, by targeting Java applications specifically (rather than providing a general-purpose container build tool) Jib is able to make some creative optimizations like:</p>

<ul>
  <li>Using <a href="https://github.com/GoogleContainerTools/distroless">distroless</a> base images that contain <em>only</em> the JVM (not even a full OS!) which makes your images a lot smaller</li>
  <li>Taking better advantage of image layering by splitting your dependencies (which tend to change less) into a separate layer from your classes (which change often). This gives you faster incremental builds since most builds only require re-building the smaller application layer.</li>
</ul>

<p>Thanks to these tricks, Jib images are usually smaller and build faster than traditional Docker + Dockerfile-based images.</p>

<p>More info on Jib:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=H6gR_Cv4yWI">Jib presentation from Oreilly Velocity 2018</a></li>
  <li><a href="https://cloud.google.com/blog/topics/developers-practitioners/comparing-containerization-methods-buildpacks-jib-and-dockerfile">GCP Blog Post on JVM Containerization Options</a></li>
  <li><a href="https://www.baeldung.com/jib-dockerizing">Baeldung on using Jib</a></li>
</ul>

<h3 id="graalvm-native-images">GraalVM Native Images</h3>

<p><a href="https://www.graalvm.org/">GraalVM</a> is an alternative JVM runtime with some really cool features, one of which is the ability to do Ahead-of-Time compilation of JVM bytecode.</p>

<p>Traditionally, the JVM uses a JIT compiler to turn bytecode into native machine code at runtime. But Graal lets us do this at build time, which opens up the possibility of packaging JVM applications into self-contained, platform-specific executables, called <a href="https://www.graalvm.org/reference-manual/native-image/">Native Images</a>.</p>

<p>A native image includes all of your application’s code, its dependencies, plus the necessary Java Runtime bits like the standard library and the garbage collector. It’s all there in one standalone binary package, so you don’t even need to have <code class="language-plaintext highlighter-rouge">java</code> installed anymore.</p>

<p>Because the runtime doesn’t have to JIT all your code at startup, the resulting program also starts <em>much</em> faster and requires less memory than traditional JVM programs, making it appealing for use cases like CLI utilities where the JVM previously was not a great fit.</p>

<p>While JVM CLIs are cool, the Industry is mostly excited about native images for a different reason: <strong>Serverless</strong>.</p>

<p>Everyone wants to stuff their Java programs into a Lambda/Cloud Run/whatever function and use them on-demand, but this doesn’t work well if your bloated app takes 30 seconds to boot. So native image provides a path to running Java programs in these environments.</p>

<p>So what’s the catch? Well there are 2 main ones:</p>

<ol>
  <li>Restrictions of the native image AOT process mean that some runtime features like reflection don’t work well or at all. In some cases there are workarounds but YMMV. <a href="https://www.graalvm.org/reference-manual/native-image/Reflection/">Consult the docs</a>. (<strong>Side note</strong>: Ironically this has led to a wave of backpedalling across the industry, as everyone scrambles to get things like Spring running without reflection. Suddenly reflection is bad and compile time abstractions are cool in Java.)</li>
  <li>So far, native image performance is at <a href="https://github.com/oracle/graal/issues/1069#issuecomment-473649871">least different, and generally slightly worse</a>, than traditional JVMs. The AOT process is able to make fewer optimizations than the traditional JIT, so your “warmed up” throughput will usually be worse. There are some workarounds, like <a href="https://www.graalvm.org/reference-manual/native-image/PGO/">PGO</a>, and this landscape continues to evolve, so again, do your research.</li>
</ol>

<p>GraalVM is really an amazing technological advancement for the JVM. It’s the kind of thing that Java developers 15 years ago would not have believed to be possible. Will be very interesting to see where this and similar advancements take us in the coming years.</p>

<h2 id="summary">Summary</h2>

<p>So there’s your crash course in JVM app packaging. There are a ton of details surrounding this topic, so we’ve inevitably had to skip over a lot. But hopefully it provides an overview of the landscape, and serves as a starting point to make informed further research elsewhere.</p>

<p>What’s next? I’m sure you must be thinking: “<em>Wow, with a rock-solid runtime and so many great deployment options, surely everything must work perfectly in production?</em>”</p>

<p>Ha! If only! Just whisper the words <code class="language-plaintext highlighter-rouge">ClassNotFoundException</code> to a Java developer and see how they react.</p>

<p>Unfortunately, it does not, in fact, all work perfectly in production. To learn more about this, stay tuned for <strong>Part 3</strong>, in which we will descend into Classpath Hell, and hopefully emerge singed, but enlightened.</p>

</article>

      </main>

    </div>

  </body>
</html>
