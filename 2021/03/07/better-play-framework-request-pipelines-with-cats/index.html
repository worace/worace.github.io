<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="last-modified" content="2022-02-23T18:49:24-08:00" />

  <title>
    
      Play! Nice: Better Play Framework Pipelines with Cats Effect
    
  </title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@300;400&family=Lora:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet"> 

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/TroutIcon48x48.png">
  <link rel="alternate" type="application/atom+xml" title="Horace Williams" href="/atom.xml">

  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117025935-1"></script>
  <script>
   window.dataLayer = window.dataLayer || [];
   function gtag(){dataLayer.push(arguments);}
   gtag('js', new Date());

   gtag('config', 'UA-117025935-1');
  </script>
  
</head>


  <body>

    <div class="container content">
      
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">Horace Williams</a>
        </h3>
        <ul class="nav-links">
          <li><a href="/about">about</a></li>
          <li><a target="_blank" class="nav-twitter" href="https://twitter.com/worace"><svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><path d="M 32 6 C 26.568583 6 22.160643 10.388731 22.042969 15.792969 C 17.240727 15.216998 14.113589 13.421507 12.195312 11.652344 C 10.067982 9.6903754 9.3945312 7.9472656 9.3945312 7.9472656 A 1.50015 1.50015 0 0 0 6.8007812 7.5996094 C 6.8007812 7.5996094 5 10 5 13.5 C 5 15.500985 5.6317952 16.981554 6.3847656 18.236328 C 6.3570276 18.223338 6.1699219 18.158203 6.1699219 18.158203 A 1.50015 1.50015 0 0 0 4.0058594 19.636719 C 4.0058594 19.636719 4.5832039 23.856843 8.5507812 26.941406 L 8.1367188 27.044922 A 1.50015 1.50015 0 0 0 7.1972656 29.244141 C 7.1972656 29.244141 7.8700527 30.382221 9.2792969 31.580078 C 10.11485 32.290298 11.34227 33.023169 12.789062 33.701172 C 11.012271 34.35044 8.362818 35 4.5 35 A 1.50015 1.50015 0 0 0 3.3710938 37.488281 C 3.3710938 37.488281 4.5173251 38.751002 6.7832031 39.849609 C 9.0490812 40.948217 12.539474 42 17.5 42 C 26.219697 42 32.484656 37.817151 36.394531 32.515625 C 40.304407 27.214099 42 20.861111 42 16 C 42 15.691547 41.980739 15.387437 41.953125 15.085938 C 44.064371 13.051602 44.856626 11.522235 44.894531 11.447266 C 45.084531 11.066266 45.01375 10.608688 44.71875 10.304688 C 44.42475 9.9996875 43.969031 9.9137969 43.582031 10.091797 L 43.419922 10.166016 C 43.280922 10.230016 43.141953 10.294422 43.001953 10.357422 C 43.408953 9.7084219 43.730125 9.014875 43.953125 8.296875 C 44.077125 7.900875 43.943234 7.4669375 43.615234 7.2109375 C 43.287234 6.9549375 42.835469 6.9275312 42.480469 7.1445312 C 41.258221 7.8873594 40.086652 8.40739 38.867188 8.7558594 C 37.072578 7.0534724 34.656873 6 32 6 z M 32 9 C 35.883178 9 39 12.116822 39 16 C 39 20.138889 37.445593 26.035901 33.980469 30.734375 C 30.515344 35.432849 25.280303 39 17.5 39 C 13.7348 39 11.230189 38.318942 9.3535156 37.582031 C 11.319341 37.276755 13.011947 36.869367 14.228516 36.398438 C 16.338182 35.581792 17.476563 34.638672 17.476562 34.638672 A 1.50015 1.50015 0 0 0 16.863281 32.044922 C 14.140556 31.364241 12.394328 30.263307 11.298828 29.345703 L 12.863281 28.955078 A 1.50015 1.50015 0 0 0 13.039062 26.099609 C 9.7939415 24.851486 8.4312292 23.086373 7.734375 21.607422 C 8.5823538 21.782967 9.3718961 22 10.5 22 A 1.50015 1.50015 0 0 0 11.169922 19.158203 C 11.169922 19.158203 8 17.7 8 13.5 C 8 12.745947 8.2088435 12.268355 8.3613281 11.697266 C 8.884507 12.400354 9.3156815 13.07859 10.160156 13.857422 C 12.734824 16.231954 16.990366 18.653154 23.419922 18.998047 A 1.50015 1.50015 0 0 0 25 17.5 L 25 16 C 25 12.116822 28.116822 9 32 9 z"/></svg>
</a></li>
        </ul>
      </header>
      

      <main>
        <article class="post">
  <h1 class="post-title">Play! Nice</h1>
  <h2 class="post-subtitle"><em>Better Play Framework Pipelines with Cats Effect</em></h2>
  <time datetime="2021-03-07T00:00:00-08:00" class="post-date">07 Mar 2021</time>
  <h2 id="summary">Summary</h2>

<p>TL;DR: Play is mostly pretty good but the built-in <a href="https://www.playframework.com/documentation/2.8.x/ScalaActionsComposition">Action Composition</a> helpers can be hard to use.</p>

<p>Instead, roll your own, using cats-effect to model a web request pipeline:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">EitherT</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">play.api.mvc.Result</span>

<span class="k">object</span> <span class="nc">PipelineTypes</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Result</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">PipelineRes</span> <span class="o">=</span> <span class="nc">PipelineStage</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then add some extensions and helpers to integrate the new model with existing types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mixin for your Play controllers</span>
<span class="k">trait</span> <span class="nc">PipelineHelpers</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">PipelineTypes._</span>

  <span class="k">def</span> <span class="nf">cc</span><span class="k">:</span> <span class="kt">play.api.mvc.ControllerComponents</span> <span class="c1">// Provide this from your controller instances</span>

  <span class="k">def</span> <span class="nf">Handler</span><span class="o">(</span><span class="n">h</span><span class="k">:</span> <span class="o">(</span><span class="kt">Request</span><span class="o">[</span><span class="kt">AnyContent</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">PipelineRes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Action</span><span class="o">[</span><span class="kt">AnyContent</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nv">cc</span><span class="o">.</span><span class="py">actionBuilder</span><span class="o">.</span><span class="py">async</span> <span class="o">{</span> <span class="n">req</span><span class="k">:</span> <span class="kt">Request</span><span class="o">[</span><span class="kt">AnyContent</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nf">h</span><span class="o">(</span><span class="n">req</span><span class="o">).</span><span class="py">fold</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">).</span><span class="py">unsafeToFuture</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Extension methods to adapt common types into pipelines</span>
<span class="k">object</span> <span class="nc">PipelineExtensions</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">IOOptionExts</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
    <span class="c1">// IO[Option[MyRecord]](None).orNotFound</span>
    <span class="c1">// Handles the very common "load this record from DB and give 404 if it's not there"</span>
    <span class="k">def</span> <span class="nf">orNotFound</span><span class="k">:</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nf">orRes</span><span class="o">(</span><span class="nc">NotFound</span><span class="o">(</span><span class="s">"Not Found"</span><span class="o">))</span>

    <span class="c1">// IO[Option[MyRecord]](None).orRes(Redirect("/pizza"))</span>
    <span class="k">def</span> <span class="nf">orRes</span><span class="o">(</span><span class="n">res</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span><span class="k">:</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span> <span class="o">{</span>
      <span class="nv">r</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">o</span> <span class="k">=&gt;</span> <span class="nv">Either</span><span class="o">.</span><span class="py">fromOption</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">res</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// pass any IO[A] through to a pipeline context by calling .piped</span>
  <span class="c1">// IO("some data").piped -&gt; EitherT[IO, Result, String]</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">IOToPipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">piped</span><span class="k">:</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span> <span class="o">{</span>
      <span class="nv">r</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">Either</span><span class="o">.</span><span class="py">right</span><span class="o">[</span><span class="kt">Result</span>, <span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// ...add your own as needed</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then use it in a controller for nice clean <code class="language-plaintext highlighter-rouge">for / yield</code> request pipelines:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyController</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">download</span><span class="o">(</span><span class="n">fileId</span><span class="k">:</span> <span class="kt">UUID</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Handler</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">req</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">u</span> <span class="k">&lt;-</span> <span class="nv">Pipeline</span><span class="o">.</span><span class="py">authed</span> <span class="c1">// reusable auth pipeline: PipelineStage[User]</span>
      <span class="n">savedFile</span> <span class="k">&lt;-</span> <span class="nv">myApp</span><span class="o">.</span><span class="py">uploads</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">uploadId</span><span class="o">).</span><span class="py">orNotFound</span>
      <span class="c1">// Permission helper I have added -- gives PipelineStage[E] for the permitted entity</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">Pipeline</span><span class="o">.</span><span class="py">permitted</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="nv">Permission</span><span class="o">.</span><span class="py">View</span><span class="o">,</span> <span class="n">savedFile</span><span class="o">)</span>
      <span class="n">url</span> <span class="k">&lt;-</span> <span class="nv">myApp</span><span class="o">.</span><span class="py">cloudStorage</span><span class="o">.</span><span class="py">signedDownloadUrl</span><span class="o">(</span><span class="n">upload</span><span class="o">).</span><span class="py">piped</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
      <span class="nc">Redirect</span><span class="o">(</span><span class="nv">url</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="long-version">Long Version</h2>

<p>In the last few months I’ve been doing some work on a growing Play Framework project in Scala. Play seems to have fallen slightly in the hype cycle, but it’s pretty solid. As far as statically typed full-stack web dev goes it’s one of the better options available in any language.</p>

<p>Here’s a super abbreviated list of some of the good parts:</p>

<ul>
  <li>Solid implementation of MVC patterns</li>
  <li>Built-in support for all the web handling goodies you need (sessions, CORS, CSRF, Forms, Flash, Response Formats, etc)</li>
  <li>Statically typed routing + parameter handling – Seriously, if you forget a route or mis-match a parameter between your routes and your controller, your app won’t compile</li>
  <li>Statically typed web templates – No more <code class="language-plaintext highlighter-rouge">ActionView::TemplateError</code> b/c you mis-named an instance variable in your template</li>
  <li>Helpers and Plugins for common web tasks like asset digesting</li>
  <li>Fast Enough (TM) for most use-cases, as long as you don’t get too sloppy blocking threads when you shouldn’t</li>
</ul>

<p>So all that stuff is great, and makes for a pretty productive dev experience. Especially given the recent “SPA Backlash” and resurgence of interest in traditional web apps with boring old server-side rendering (see e.g. <a href="https://hotwire.dev/">HotWire</a>, <a href="https://phoenixframework.org/">Phoenix</a> and <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">Phoenix LiveView</a>, <a href="https://whatisjasongoldstein.com/writing/help-none-of-my-projects-want-to-be-spas/">Help! None of my projects want to be SPAs</a>), maybe we’ll see some revived interest in Play. Who knows – maybe there could even be a Play variant of the HotWire/LiveView style of server-based dynamic rendering at some point.</p>

<p>There are a couple smallish things that I don’t love: all the Guice and Java-style DI stuff is gross (I just don’t use it – passing args to methods is fine), and as always you have to be vigilant to keep the framework’s machinery from seeping into your domain model (use a separate sbt module for your core app vs. your web interface, a la <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">Hexagonal Architecture</a>).</p>

<p>But the biggest annoyance that IMHO keeps Play from being really great is a lack of ergonomics around customizing and chaining controller actions.</p>

<h2 id="action-composition-and-request-pipeline-abstraction-in-play">Action Composition and Request Pipeline Abstraction in Play</h2>

<h3 id="the-problem">The Problem</h3>

<p>Web applications take in an HTTP Request and, through a series of developer-defined steps, generate a corresponding HTTP Response.</p>

<p>A pattern in many web frameworks is to provide some sort of abstraction for modeling this process as a pipeline of steps. Each step can either modify the working context and continue the pipeline (loading the current user is a classic example), or abort the pipeline by providing an HTTP response.</p>

<p>The “abort and provide a response” path often represents an error state: for example a pipeline requiring an authenticated user might abort and redirect to the <code class="language-plaintext highlighter-rouge">/login</code> path if there was none. This pattern can be applied outside the context of web programming as well – sometimes it’s called <a href="https://fsharpforfunandprofit.com/rop/">Railway Oriented Programming</a>.</p>

<p>Different web frameworks have different approaches to modeling request pipelines. In Rails you have <a href="https://guides.rubyonrails.org/action_controller_overview.html#filters">filters</a> which can modify request context by manipulating the current controller instance state. Elixir’s Phoenix has a well-developed API for defining <a href="https://hexdocs.pm/phoenix/routing.html#pipelines">pipelines</a> consisting of <a href="https://hexdocs.pm/phoenix/plug.html">plugs</a>. Django follows the Python pattern of using method <a href="https://docs.djangoproject.com/en/3.1/topics/http/decorators/">decorators</a> to wrap request handlers in re-usable pipeline logic. Http4s, another popular Scala web library, takes a heavily functional and type-driven approach by modeling <a href="https://http4s.org/v0.18/middleware/">middleware</a> using <a href="https://typelevel.org/cats/datatypes/kleisli.html">Kleisli</a> + <a href="https://typelevel.org/cats/datatypes/optiont.html">OptionT</a>.</p>

<p>Reasons you’d want to use these pipeline-oriented abstractions range widely, but they’re extremely handy for keeping a web service codebase under control. Some examples of pipeline-ish things include:</p>

<ul>
  <li>Loading the current user</li>
  <li>Requiring authentication</li>
  <li>Checking permissions</li>
  <li>DRY up resource-loading code by moving common DB lookups into pipeline stages</li>
</ul>

<p>You can of course just do all these things inline in your request handlers. But having a standard way to define and re-use them helps keep your handler implementations short and focused on what is specific to each particular route.</p>

<h3 id="plays-approach">Play’s Approach</h3>

<p>In Play, <a href="https://www.playframework.com/documentation/2.8.x/ScalaActions">Action</a> is the core abstraction representing the HTTP request/response lifecycle. An Action represents the transformation <code class="language-plaintext highlighter-rouge">play.api.mvc.Request =&gt; play.api.mvc.Result</code>, which makes sense.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Action</span> <span class="o">{</span> <span class="n">request</span> <span class="k">=&gt;</span>
  <span class="nc">Ok</span><span class="o">(</span><span class="s">"Turning a Request into a Result!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For more complicated things, like the various request Pipeline cases mentioned above, Play provides some additional types and helpers for dealing with <a href="https://www.playframework.com/documentation/2.8.x/ScalaActionsComposition">Action Composition</a>:</p>

<ul>
  <li><a href="https://www.playframework.com/documentation/2.8.x/api/scala/play/api/mvc/ActionFilter.html">ActionFilter</a> - Pass the request through unmodified, or exit the pipeline early by providing a response</li>
  <li><a href="https://www.playframework.com/documentation/2.8.x/api/scala/play/api/mvc/ActionRefiner.html">ActionRefiner</a> - Like ActionFilter, except that you can modify the Request type (e.g. to provide new context)</li>
  <li><a href="https://www.playframework.com/documentation/2.8.x/api/scala/play/api/mvc/ActionTransformer.html">ActionTransformer</a> - Transform one request to another (no chance for early exit)</li>
  <li><a href="https://www.playframework.com/documentation/2.8.x/api/scala/play/api/mvc/ActionBuilder.html">ActionBuilder</a> - Not really part of the filter/refine/transform Pipeline API per se, but gives some helpers for constructing Actions</li>
  <li><a href="https://www.playframework.com/documentation/2.8.x/api/scala/play/api/mvc/ActionFunction.html">ActionFunction</a> - Base type for all of the above – you generally won’t use it directly.</li>
</ul>

<p>From the descriptions and from reading examples in the docs, these all seem reasonable.</p>

<p>But unfortunately, in my experience, they’re just absolutely <strong>maddening</strong> to work with.</p>

<p>It’s hard for me to accurately describe all of the various issues I’ve run into (I wish I had done a better job at saving the many compiler errors and use-cases I’ve failed to implement with these APIs), but I can say they were quite deterring. I may not be the most expert Scala user in the whole world, but I’m not bad, and my success rate in doing anything slightly non-trivial with Action handling in Play is about 1 in 6.</p>

<p>I’m not sure I really understand all of the API design subtleties at play (ha!) with these features, but my hunch is that it comes down to some combination of these:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">Action*</code> APIs are all generic over the type of the incoming request body, as well as over the type of the Request being handled. For example in <code class="language-plaintext highlighter-rouge">trait ActionBuilder[+R[_], B]</code>, the <code class="language-plaintext highlighter-rouge">B</code> represents an HTTP Body, for which you must provide a corresponding <code class="language-plaintext highlighter-rouge">BodyParser[B]</code>, while the <code class="language-plaintext highlighter-rouge">+R[_]</code> represents a Request. The request has to be generic because you might have to swap it out for your own (more on that in a second). This may be a reasonable and correct way to model this stuff, but for inexperienced users it becomes unwieldy quickly.</li>
  <li>These APIs are all inheritance (trait) based which means you have to interface with them via defining new classes of your own. This leads to a lot of boilerplate, and makes it hard to quickly spin up ad-hoc implementations as you go. Especially once you start wanting to introduce your own parameters (to allow call-site customization of the Actions you’re building), it gets really hard to keep your definitions inline with the inheritance interfaces required by the base traits.</li>
  <li>As a statically typed framework, Play faces a challenge of what to do with new <strong>contextual data</strong> during Request processing.</li>
</ol>

<p>Even if you can master enough of the type hierarchy awareness required to confidently develop around points 1 and 2, point 3 turns out to be a pretty significant hurdle in providing a convenient developer API.</p>

<p>Why is this such a problem for Play? Well, in dynamic language web frameworks, it’s common to stuff arbitrary data into the request context. For example in a Rails controller any object can be stashed as an instance variable at any point and thus retrieved via subsequent steps. Elixir’s Plug provides an <a href="https://hexdocs.pm/plug/Plug.Conn.html#assign/3">assigns</a> field on its <code class="language-plaintext highlighter-rouge">Conn</code> type for a similar purpose.</p>

<p>Play provides a statically typed solution in the form of <a href="https://www.playframework.com/documentation/2.8.x/api/scala/play/api/mvc/WrappedRequest.html">WrappedRequest</a>. For example it’s very common to see applications define a <code class="language-plaintext highlighter-rouge">UserRequest</code> for tracking the authentication state of the request:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRequest</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="nv">user</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">],</span> <span class="n">request</span><span class="k">:</span> <span class="kt">Request</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">WrappedRequest</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">request</span><span class="o">)</span>
</code></pre></div></div>

<p>Then you’d define a custom <code class="language-plaintext highlighter-rouge">ActionBuilder</code> which takes an existing request, fetches your user, and wraps it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserAction</span> <span class="c1">// Some constructor boilerplate elided here...</span>
  <span class="c1">// mapping from a Request to a UserRequest</span>
  <span class="k">extends</span> <span class="nc">ActionTransformer</span><span class="o">[</span><span class="kt">Request</span>, <span class="kt">UserRequest</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">transform</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">baseRequest</span><span class="k">:</span> <span class="kt">Request</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">user</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span> <span class="c1">// go get your user</span>
    <span class="nv">user</span><span class="o">.</span><span class="py">map</span> <span class="o">{</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">UserRequest</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">baseRequest</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ok, makes sense I guess.</p>

<p>But what if I need further composition? Maybe I have a <code class="language-plaintext highlighter-rouge">WidgetController</code> where I want to have a transformer to load a <code class="language-plaintext highlighter-rouge">Widget</code>. Well that could be an <code class="language-plaintext highlighter-rouge">ActionTransformer[UserRequest, WidgetRequest]</code>. And maybe there’s also a nested route where widgets can also have <code class="language-plaintext highlighter-rouge">Order</code>s I want to load, so that would be <code class="language-plaintext highlighter-rouge">ActionTransformer[WidgetRequest, OrderRequest]</code>.</p>

<p>So this is a little bit annoying, since I have to roll a new custom <code class="language-plaintext highlighter-rouge">WrappedRequest</code> instance for each of these scenarios. But it’s at least tractable.</p>

<p>However, what I if I also want to have an <code class="language-plaintext highlighter-rouge">OrderRequest</code> where I <em>didn’t</em> load the widget first? Well, requiring concrete implementations for each variant of Request context I need to model forces me to spin up new definitions for every <strong>combination</strong> of flow we’d need. It’s very challenging to do them ad-hoc.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UserRequest --&gt; WidgetRequest --&gt; WidgetOrderRequest
UserRequest --&gt; UserOrderRequest
FooRequest --&gt; FooOrderRequest ---&gt; I can't just re-use my order-loading filter :(
</code></pre></div></div>

<p><strong>Aside:</strong> I’ve been loosely following how web tools in the Rust ecosystem solve this problem, since they face similar challenges. <a href="https://rocket.rs/">Rocket</a> for example uses an interesting combination of <a href="https://api.rocket.rs/v0.4/rocket/attr.get.html">routing macros</a> and <a href="https://api.rocket.rs/v0.4/rocket/request/trait.FromRequest.html">typeclasses</a>. I haven’t had a chance to dig into this but hope to explore it further.</p>

<h3 id="an-alternative-making-friends-with-cats">An Alternative: Making Friends with Cats</h3>

<p>After struggling with the Action API for a while I finally decided maybe things don’t actually have to be this complicated. The <a href="https://fsharpforfunandprofit.com/rop/">Railway</a> model really feels like the right thing here: I need a simple way to express the optionality of exiting early (with an HTTP response) or continuing the pipeline, potentially with additional new context.</p>

<p>In dynamic langs, this is easy, because we can duck-type our way through it:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># elixir example in phoenix</span>
<span class="c1"># Framework checks for an early response between each stage</span>
<span class="c1"># As long as you don't botch the return type from a stage too badly, you'll be ok</span>
<span class="n">pipeline</span> <span class="ss">:browser</span> <span class="k">do</span>
  <span class="n">plug</span> <span class="ss">:accepts</span><span class="p">,</span> <span class="p">[</span><span class="s2">"html"</span><span class="p">]</span>
  <span class="n">plug</span> <span class="ss">:fetch_session</span>
  <span class="n">plug</span> <span class="ss">:fetch_flash</span>
  <span class="n">plug</span> <span class="ss">:protect_from_forgery</span>
  <span class="n">plug</span> <span class="ss">:put_secure_browser_headers</span>
<span class="k">end</span>
</code></pre></div></div>

<p>But in Scala we need to express it statically, and one way to do it is using <code class="language-plaintext highlighter-rouge">Either</code>.</p>

<p>Each intermediate stage of a web request “pipeline” can either return an early Response, or continue with new info: <code class="language-plaintext highlighter-rouge">Either[play.api.mvc.Result, A]</code>. For the final (non-intermediate) step of the pipeline, the righthand response must also be a <code class="language-plaintext highlighter-rouge">Result</code>, so you have <code class="language-plaintext highlighter-rouge">Either[play.api.mvc.Result, play.api.mvc.Result]</code>.</p>

<p>Then, there’s 1 more hiccup, which is that most web programming in Scala is going to be done async, with an effect type. In Play this is usually <code class="language-plaintext highlighter-rouge">Future</code>, but in my own application I’m also using <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>.</p>

<p>So my types actually end up as <code class="language-plaintext highlighter-rouge">IO[Either[play.api.mvc.Result, A]]</code>. This nesting can be cumbersome, so I’ve brought in <a href="https://typelevel.org/cats/datatypes/eithert.html">EitherT</a> from Cats to manage it.</p>

<p>So…in my app I have some custom types like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">EitherT</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">play.api.mvc.Result</span>

<span class="k">object</span> <span class="nc">PipelineTypes</span> <span class="o">{</span>
  <span class="c1">// As mentioned, I'm using cats.effect.IO here.</span>
  <span class="c1">// But you could also achieve the same with Future</span>
  <span class="c1">// Or if you want to be really fancy make this tagless final to generalize to other effects</span>
  <span class="k">type</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Result</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">PipelineRes</span> <span class="o">=</span> <span class="nc">PipelineStage</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And I add a helper to my controller to provide an alternative to the default <code class="language-plaintext highlighter-rouge">Action</code> builder:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">PipelineHelpers</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">PipelineTypes._</span>

  <span class="k">def</span> <span class="nf">cc</span><span class="k">:</span> <span class="kt">play.api.mvc.ControllerComponents</span> <span class="c1">// Provide this from your controller instances</span>

  <span class="k">def</span> <span class="nf">Handler</span><span class="o">(</span><span class="n">h</span><span class="k">:</span> <span class="o">(</span><span class="kt">Request</span><span class="o">[</span><span class="kt">AnyContent</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">PipelineRes</span><span class="o">)</span><span class="k">:</span> <span class="kt">Action</span><span class="o">[</span><span class="kt">AnyContent</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nv">cc</span><span class="o">.</span><span class="py">actionBuilder</span><span class="o">.</span><span class="py">async</span> <span class="o">{</span> <span class="n">req</span><span class="k">:</span> <span class="kt">Request</span><span class="o">[</span><span class="kt">AnyContent</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="c1">// here is the "end of the world", where the Cats Effects</span>
      <span class="c1">// get turned into side effects</span>
      <span class="nf">h</span><span class="o">(</span><span class="n">req</span><span class="o">).</span><span class="py">fold</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">).</span><span class="py">unsafeToFuture</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So now your controllers can use <code class="language-plaintext highlighter-rouge">Handler</code> instead of <code class="language-plaintext highlighter-rouge">Action</code>, and skip the Play <code class="language-plaintext highlighter-rouge">ActionBuilder</code> machinery entirely.</p>

<p>And, since it uses <code class="language-plaintext highlighter-rouge">EitherT</code>…to chain pipeline stages you can just <code class="language-plaintext highlighter-rouge">for / yield</code> like normal:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">download</span><span class="o">(</span><span class="n">fileId</span><span class="k">:</span> <span class="kt">UUID</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Handler</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">req</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">u</span> <span class="k">&lt;-</span> <span class="nv">Pipeline</span><span class="o">.</span><span class="py">authed</span> <span class="c1">// reusable auth pipeline: PipelineStage[User]</span>
      <span class="n">savedFile</span> <span class="k">&lt;-</span> <span class="nv">myApp</span><span class="o">.</span><span class="py">uploads</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">uploadId</span><span class="o">).</span><span class="py">orNotFound</span>
      <span class="c1">// Permission helper I have added -- gives PipelineStage[E] for the permitted entity</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">Pipeline</span><span class="o">.</span><span class="py">permitted</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="nv">Permission</span><span class="o">.</span><span class="py">View</span><span class="o">,</span> <span class="n">savedFile</span><span class="o">,</span> <span class="o">())</span>
      <span class="n">url</span> <span class="k">&lt;-</span> <span class="nv">myApp</span><span class="o">.</span><span class="py">cloudStorage</span><span class="o">.</span><span class="py">signedDownloadUrl</span><span class="o">(</span><span class="n">upload</span><span class="o">).</span><span class="py">piped</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
      <span class="nc">Redirect</span><span class="o">(</span><span class="nv">url</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>What about <code class="language-plaintext highlighter-rouge">orNotFound</code> or <code class="language-plaintext highlighter-rouge">piped</code>? I added these extensions in my controllers to adapt common datatypes into this pipeline model.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">PipelineExtensions</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">IOOptionExts</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
    <span class="c1">// IO[Option[MyRecord]](None).orNotFound</span>
    <span class="c1">// Handles the very common "load this record from DB and give 404 if it's not there"</span>
    <span class="k">def</span> <span class="nf">orNotFound</span><span class="k">:</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nf">orRes</span><span class="o">(</span><span class="nc">NotFound</span><span class="o">(</span><span class="s">"Not Found"</span><span class="o">))</span>

    <span class="c1">// IO[Option[MyRecord]](None).orRes(Redirect("/pizza"))</span>
    <span class="k">def</span> <span class="nf">orRes</span><span class="o">(</span><span class="n">res</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span><span class="k">:</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span> <span class="o">{</span>
      <span class="nv">r</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">o</span> <span class="k">=&gt;</span> <span class="nv">Either</span><span class="o">.</span><span class="py">fromOption</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">res</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// pass any IO[A] through to a pipeline context by calling .piped</span>
  <span class="c1">// IO("some data").piped -&gt; EitherT[IO, Result, String]</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">IOToPipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">piped</span><span class="k">:</span> <span class="kt">PipelineStage</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span> <span class="o">{</span>
      <span class="nv">r</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">Either</span><span class="o">.</span><span class="py">right</span><span class="o">[</span><span class="kt">Result</span>, <span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Over time I’ve accumulated maybe 50 lines or so of these helpers, but they’ve been quite stable. Compared to the hours lost fighting with the built-in play framework Action builders, this approach has been quite productive for me. And, maybe best of all, my controller code is <em>much</em> cleaner.</p>

<p>It’s very common in Play framework code to see big nested controller methods due to the complexities of handling effect types (<code class="language-plaintext highlighter-rouge">Future</code>) alongside the various error cases that can arise. But I just don’t have that anymore. Instead all my controller methods are nice linear stacks of <code class="language-plaintext highlighter-rouge">for { ... } yield { SomeResponse (...) }</code>.</p>

<p>To me, <code class="language-plaintext highlighter-rouge">for / yield</code> (i.e. a bunch of <code class="language-plaintext highlighter-rouge">flatMap</code>s in a trenchcoat) is the natural way to handle this kind of railway chaining in Scala. It’s much nicer to compose these ad-hoc scopes on the fly rather than have to define a new concrete <code class="language-plaintext highlighter-rouge">WrappedRequest</code> and a bunch of OOP boilerplate for each permutation of re-usable scope you might want to chain.</p>

<p>I’ve also found the experience of using <code class="language-plaintext highlighter-rouge">EitherT</code> in this way to actually be pretty good. I was nervous about relying on it so heavily because I know it can give terrible compiler messages in some cases. But I haven’t had too many issues. My hunch is that it helps to have the whole pipeline wrapped in the outer <code class="language-plaintext highlighter-rouge">Handler</code> helper: <code class="language-plaintext highlighter-rouge">def Handler(h: (Request[AnyContent]) =&gt; PipelineRes): Action[AnyContent]</code>, which keeps the type inference constrained compared to an open-ended <code class="language-plaintext highlighter-rouge">EitherT</code>.</p>

<p>So, that’s the gist of it. This may seem like a lot of fuss about a narrow slice of the application, but in my experience the handling of request pipelines is one of the most fundamental points of ergonomics for a web framework. How this is handled sets the groundwork for how clean and reusable your web-layer code can be.</p>

<p>Doing it cleanly in a statically typed language like Scala isn’t trival, but the benefits are also great: I now have an API that approaches the convenience and conciseness of things like Rails but is also compiler-verified all the way from routing to templates.</p>

<h2 id="other-thoughts">Other thoughts</h2>

<h3 id="how-does-this-compare-with-http4s-kleisli-setup">How does this compare with http4s’ Kleisli setup?</h3>

<p>Honestly I’m not sure and I’d like to understand it better. I have not used http4s much, and Kleisli has so far been a bridge too far in my own personal FP journey. Maybe I’ll get there evenutally but whenever I’ve looked at it I’ve found it too abstract. My hunch is that the <code class="language-plaintext highlighter-rouge">Kliesli</code> / <code class="language-plaintext highlighter-rouge">OptionT</code> approach to middleware used in http4s is solving a similar problem, and may even be isomorphic to what I’m doing with these <code class="language-plaintext highlighter-rouge">EitherT</code> helpers. Maybe someone who knows FP better can explain this to me.</p>

<h3 id="what-about-zio">What about ZIO?</h3>

<p>I don’t really know. I haven’t tried to use it yet nor had a chance to research it thoroughly. I’m a touch put off by all the hype / marketing being poured on, but would like to take a look at some point.</p>

<p>I’m not sure what the HTTP / Web Server situation is in ZIO but I could imagine some benefits from using the error channel to handle similar things to what I’m doing here (I know <code class="language-plaintext highlighter-rouge">ZIO</code> is often billed as a nicer <code class="language-plaintext highlighter-rouge">EitherT</code> alternative). However I’ve been pretty happy with <code class="language-plaintext highlighter-rouge">EitherT</code> in this scenario so I don’t feel a ton of need to branch out. And I tend to manage the Dependency Injection aspects of my apps with plain old arg passing and object constructors, so I’m not sure I would get as much value from the Reader / Env channel. But I hope to have a chance to learn more about this at some point.</p>

<h3 id="what-about-eithert-overhead">What about EitherT overhead?</h3>

<p>I’ve seen occasional discussion about the overhead introduced by all the wrapping involved with monad transformers like <code class="language-plaintext highlighter-rouge">EitherT</code> (oops I almost got through this whole post without saying the M-word). I’m sure there is some cost to this – you’re obviously allocating more objects and adding method calls to your code path. But most of my endpoints are doing at least 1 DB lookup already, if not many DB lookups, so it’s just hard for me to imagine this overhead adds up to anything significant in comparison.</p>

<p>I have not taken the time to microbenchmark these aspects of the app, but I have certainly run load tests (via <a href="https://github.com/gatling/gatling">gatling</a>) and the results there have been perfectly fine.</p>

<p>Maybe my use-case is different – I’m deliberately doing “full stack” web work here, with lots of data lookups, etc, and I’m much more concerned with dev ergonomics and code cleanliness than I am with micro-optimizing a few milliseconds off of my endpoints. But as it is I’m confident that even on a modestly resourced server this setup will be humming along happily long after my database (which is the real bottleneck) has given up the ghost.</p>

</article>

      </main>

    </div>

  </body>
</html>
